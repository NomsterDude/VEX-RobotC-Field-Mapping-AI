#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    leftLineFollower, sensorLineFollower)
#pragma config(Sensor, in2,    centerLineFollower, sensorLineFollower)
#pragma config(Sensor, in3,    rightLineFollower, sensorLineFollower)
#pragma config(Sensor, in6,    gyro,           sensorGyro)
#pragma config(Sensor, dgtl6,  touchSensor,    sensorTouch)
#pragma config(Sensor, dgtl8,  sonarSensor,    sensorSONAR_cm)
#pragma config(Sensor, dgtl11, armEncoder,     sensorQuadEncoder)
#pragma config(Sensor, I2C_1,  rightEncoder,   sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  leftEncoder,    sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_3,  armIME,         sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port1,           RightMotor, tmotorVex393_HBridge, openLoop, reversed, driveLeft, encoderPort, I2C_2)
#pragma config(Motor,  port2,           LeftMotor, tmotorVex393_MC29, openLoop, reversed)
//#pragma config(Motor,  port3,           frontLeftMotor, tmotorVex393_MC29, openLoop) not using
//#pragma config(Motor,  port4,           backLeftMotor, tmotorVex393_MC29, openLoop) not using
#pragma config(Motor,  port4,           clawMotor,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           armMotor,      tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_3)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//42 CM wide

//SensorValue[sonarSensor]

//0 is forward, 1 is left, 2 is right

//DIR VAR:  0 is up, 1 is left, 2 is right, 3 is down

task main() {
	int dir = 0;  //direction of robot
	int basePos[] = {1, 1};  //{x, y}
	int pos[] = {2, 1};  //current pos of robot
	int targetPos[] = {3, 2};  //pos to get to

	/*
	EXAMPLES:

	dir = 0, pos = {2, 1}, target pos = {3, 2}
	array should be {2, 0, 1, 0}

	*/

	int movement[25];  //instructions array - Anything above 2 is an illegal value and the remainder won't be parsed.  Can increase or decrease.

	int loopNum = 0;
	bool shouldBreak = false;
	while (pos[0] != targetPos[0] || pos[1] != targetPos[1]) {  //goes x first then y
		shouldBreak = false;
		if (pos[0] < targetPos[0]) {  //need to go right - dir should be 2
			switch (dir) {
				case 0:
				movement[loopNum] = 2;
				dir = 2;
				shouldBreak = true;
				break;

				case 1:
				movement[loopNum] = 2;
				dir = 0;
				shouldBreak = true;
				break;

 				case 3:
				movement[loopNum] = 1;
				dir = 2;
				shouldBreak = true;
				break;

				default:
				//nothing
			}
			if (!shouldBreak) {
				movement[loopNum] = 0;
				pos[0]++;
			}
		} else if (pos[0] > targetPos[0]) {  //need to go left - dir should be 1
				switch (dir) {
					case 0:
					movement[loopNum] = 1;
					dir = 1;
					shouldBreak = true;
					break;

					case 2:
					movement[loopNum] = 2;
					dir = 3;
					shouldBreak = true;
					break;

					case 3:
					movement[loopNum] = 2;
					dir = 1;
					shouldBreak = true;
					break;

					default:
					//nothing
				}
				if (!shouldBreak) {
					movement[loopNum] = 0;
					pos[0]--;
				}
		} else if (pos[1] < targetPos[1]) {  //need to go up - dir should be 0
				switch (dir) {
					case 1:
					movement[loopNum] = 2;
					dir = 0;
					shouldBreak = true;
					break;

					case 2:
					movement[loopNum] = 1;
					dir = 0;
					shouldBreak = true;
					break;

					case 3:
					movement[loopNum] = 2;
					dir = 1;
					shouldBreak = true;
					break;

					default:
					//nothing
				}
				if (!shouldBreak) {
					movement[loopNum] = 0;
					pos[1]++;
				}
		} else if (pos[1] > targetPos[1]) {  //need to go down - dir should be 3
				switch (dir) {
					case 1:
					movement[loopNum] = 1;
					dir = 3;
					shouldBreak = true;
					break;

					case 2:
					movement[loopNum] = 2;
					dir = 3;
					shouldBreak = true;
					break;

					case 0:
					movement[loopNum] = 2;
					dir = 2;
					shouldBreak = true;
					break;

					default:
					//nothing
				}
				if (!shouldBreak) {
					movement[loopNum] = 0;
					pos[1]--;
				}
		}
		loopNum++;
	}
	wait1Msec(100000);
}
